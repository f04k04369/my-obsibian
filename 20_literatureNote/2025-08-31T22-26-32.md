---
tags: []
aliases:
UID: 2025-08-31T22-26-32
date: 2025-08-31 22:26
---

# AIと行うDB設計：箇条書きからリレーション・制約まで自動生成
![](https://relay-dsp.ad-m.asia/dmp/sync/bizmatrix?pid=c3ed207b574cf11376&d=x18o8hduaj&uid=4150017)

[@yoshiichn](https://qiita.com/yoshiichn) in [株式会社ディーバ](https://qiita.com/organizations/fierte-pd)

投稿日

### はじめに

社内システムを構築するにあたりDB設計担当となりました。

データベース設計は、システムの根幹をなす重要な工程なので、DB設計初心者にとっては非常にハードルの高い作業となりがちです。

私も5年前に少し触ったことがあるだけであまり自信がなかったですが、生成AIを活用することで **箇条書きで記述したテーブルとカラムの情報から、データベース設計の初期フェーズを高速化** できました。

この記事では私がやったステップを紹介したいと思います。

### 本記事で得られること

- AIを活用したDB設計ワークフロー
- 箇条書きからのAIによるリレーション・制約推論の具体的な方法
- DB設計初心者でも高速に初期設計を進めるためのヒント

---

### ステップ1. DBのテーブルとカラムの洗い出しを行う（人間）

まずは要件定義をもとに必要なデータの洗い出しを行いました。この段階ではDBテーブルの大枠をつかむために、詳細なデータ型やリレーションシップ、制約などは記載せず、「どのようなテーブルが必要か」「それぞれのテーブルにはどのようなカラムが必要か」という点に絞って項目の洗い出しだけ行いました。

例えば、簡単なECサイトを想定した場合、以下のような形でテーブル名とカラムを箇条書きで整理します。

**【人間が用意する情報例】**

```text
## ECサイトのデータベース設計（初期案）

以下のテーブルとカラムを洗い出しました。

*   ユーザー (users)
    *   id
    *   name
    *   email
    *   password_hash
    *   address
    *   created_at
    *   updated_at

*   商品 (products)
    *   id
    *   name
    *   description
    *   price
    *   stock
    *   category_id
    *   created_at
    *   updated_at

*   カテゴリ (categories)
    *   id
    *   name

*   注文 (orders)
    *   id
    *   user_id
    *   order_date
    *   total_amount
    *   status

*   注文詳細 (order_items)
    *   id
    *   order_id
    *   product_id
    *   quantity
    *   price_at_order
```

### ステップ2. 型定義、リレーション、制約はあとで追記する予定でDB定義書を作成（AI）

洗い出したテーブルとカラムの情報をAIに渡します。AIに投げるプロンプトは以下のようになります。

**【AIへのプロンプト例】**

```text
以下のECサイトのテーブルとカラムのリストを基に、Mysql用のCREATE TABLE文を作成してください。
データ型やリレーション、制約などは、あなたが適切と判断するものを仮で設定してください。

[ここに、ステップ1で人間が用意した箇条書きの情報をペースト]
```

このプロンプトには、「データ型やリレーション、制約などは、あなたが適切と判断するものを仮で設定してください」と、AIに推論の余地を与える一文を含んでいます。これにより、AIが単に文字起こしするだけでなく、積極的に推論を行うことを促します。

### ステップ3. AIが作成したDB定義書のレビューを行う（人間）

私は型などは全てVARCHARで仮置きされたCREATE TABLEの骨格だけ作成されることを想定していました。  
しかし、AIが作成したCREATE TABLE文は単なるCREATE TABLE文の骨格だけでなく、 **適切なデータ型、PRIMARY KEYやFOREIGN KEYによるリレーションシップ、NOT NULLやUNIQUEなどの制約、さらにはDEFAULT値や `ON UPDATE CURRENT_TIMESTAMP` などの詳細な設定まで自動で付与されたSQLが生成され** ました。

**【AIが生成したCREATE TABLE文の例（一部抜粋）】**

```sql
-- users テーブル
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    address TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- products テーブル
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    category_id INT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(id)
);

-- orders テーブル
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- order_items テーブル (省略)
```

この生成されたSQLを見てみると、AIが以下の点を推論していることが分かります。

- **リレーションシップ:**`orders.user_id` と `users.id` 、 `products.category_id` と `categories.id` などの関連を自動で検出し、 `FOREIGN KEY` 制約として定義しています。これは、カラム名に `_id` というサフィックスが付いていることや、一般的なシステムの構造パターンをAIが学習しているためと考えられます。
- **プライマリキーと自動増分:**`id` カラムを `PRIMARY KEY` および `AUTO_INCREMENT` として適切に設定しています。
- **データ型:**`email` を `VARCHAR(255)` 、 `price` を `DECIMAL` 、 `created_at` を `DATETIME` など、カラム名から適切なデータ型を推論しています。
- **制約:**`name` や `email` など、ビジネス上必須となるカラムには `NOT NULL` を付与。また、 `email` には `UNIQUE` 制約を付与し、一意性を保証しています。
- **デフォルト値と更新日時:**`created_at` に `DEFAULT CURRENT_TIMESTAMP` 、 `updated_at` に `DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` を付与し、自動で日時が記録・更新されるように配慮されています。

この段階で、人間は生成されたSQLをレビューし、ビジネス要件やパフォーマンス要件に合致しているかを確認します。AIが提案した内容はあくまで叩き台でしたが、ゼロから考えるよりもはるかに効率よく作業を進めることができました。

### シナリオ4. 細かい仕様の調整（AI & 人間）

AIが生成した設計案を基に、さらに詳細な調整を行います。

例えば、レビューの結果、以下のような調整が必要となりました。

- `users` テーブルの `address` は、将来的に住所情報を細分化する可能性があるため、いったん `TEXT` 型ではなく `JSON` 型に変更したい。
- `orders` テーブルの `status` カラムは、特定の文字列しか受け付けないように `ENUM` 型にしたい。
- 特定のカラムには検索性能向上のため、インデックスを追加したい。

これらの要望は、再度AIにプロンプトとして投げかけ、AIに修正案を生成させることができます。

**【AIへの追加プロンプト例】**

```text
先ほど生成してもらったECサイトのCREATE TABLE文について、以下の修正をお願いします。

*   usersテーブルのaddressカラムをTEXT型からJSON型に変更してください。
*   ordersテーブルのstatusカラムをVARCHARからENUM('pending', 'processing', 'shipped', 'completed', 'cancelled')型に変更し、デフォルト値を'pending'に設定してください。
*   productsテーブルのnameカラムにインデックスを追加してください。
```

AIはこれらの指示に従い、速やかに修正されたCREATE TABLE文を生成します。人間はその結果を再度レビューし、必要に応じてさらなる調整を指示します。この繰り返しによりDB設計を完成させることができます。

### 結論：DB設計初心者でも高速に設計を行うことができた！

AIの推論能力を活用することで、DB設計初心者でも初期のテーブルとカラムの洗い出しさえ行えれば、 **データ型、リレーションシップ、各種制約といった専門知識が必要な部分の設計を高速かつ高い精度で自動生成できる** ことが分かりました。

このアプローチにより、DB設計の初期段階で陥りがちな「何から手をつけて良いか分からない」「適切な型や制約が分からない」といった障壁を大幅に低減できます。AIが生成した設計案を叩き台として人間がレビュー・調整を行うことで、 **経験の浅いエンジニアでも短時間で質の高いDB設計を行うことが可能** になります。

AIは万能ではありませんが、適切な指示と人間のレビュー・調整を組み合わせることで、DB設計を効率よく進められることを学びました。

[0](https://qiita.com/yoshiichn/items/#comments)

コメント一覧へ移動

X（Twitter）でシェアする

Facebookでシェアする

はてなブックマークに追加する

この記事は以下の記事からリンクされています

- [【初心者】Qiita 週間いいね数ランキング【自動更新】](https://qiita.com/koki_develop/items/402899ec543aff109505)

[11](https://qiita.com/yoshiichn/items/b12195247f61e2ee62e3/likers)

いいねしたユーザー一覧へ移動

4

